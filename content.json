{"meta":{"title":"学习笔记","subtitle":"BIUBIUBIU...","description":null,"author":"会飞的汉堡包","url":"http://jeson.org"},"pages":[{"title":"标签","date":"2017-05-12T16:52:08.304Z","updated":"2017-05-11T14:37:01.823Z","comments":false,"path":"tags/index.html","permalink":"http://jeson.org/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-05-12T16:52:08.288Z","updated":"2017-05-11T14:35:37.907Z","comments":false,"path":"categories/index.html","permalink":"http://jeson.org/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"笔记-JavaWeb","slug":"笔记-JavaWeb","date":"2017-04-24T16:00:00.000Z","updated":"2017-05-13T10:49:50.848Z","comments":true,"path":"2017/04/25/笔记-JavaWeb/","link":"","permalink":"http://jeson.org/2017/04/25/笔记-JavaWeb/","excerpt":"","text":"Java Web 学习笔记 JDBCJDBC接口 驱动管理 DriveManager 连接接口 Connection DatabaseMetaData 语句对象接口 Statement PrepareStatement CallableStatement 结果集接口 ResultSet ResultSetMetaData JDBC使用步骤 导入JDBC的jar包 加载驱动 获取Connection对象 创建Statement语句对象 执行SQL语句 execute(DDL)常用于执行DDL,DCL executeUpdate(DML)常用于执行DML语句 executeQuery(DQL)常用于之赐你个DQL语句 处理执行结果 execute(DDL)如果没有异常则成功, 返回值为boolean, true为有数据集, false没有数据集 executeUpdate(DML)如果没有异常则成功, 返回数字, 更新记录的行数 executeQuery(DQL)如果没有异常则成功, 返回ResultSet结果集, 二维查询结果 关闭数据连接! 必须关闭, 否则数据库可能会瘫痪 例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.jeson.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBC &#123; private static final String url = \"jdbc:mysql://192.168.31.132:3306/db_jeson?user=jeson&amp;password=password\"; private static final String sql = \"SELECT * FROM users\"; static &#123; try &#123; // 2. 加载驱动 Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public void start() &#123; Connection conn = null; try &#123; // 3. 获取连接 conn = DriverManager.getConnection(url); // 4. 创建Statement对象 Statement stmt = conn.createStatement(); // 5. 执行SQL语句 ResultSet result = stmt.executeQuery(sql); System.out.println(\"id\\tname\\t\\tpassword\\tage\\tsex\"); // 6. 处理SQL执行结果 while (result.next()) &#123; System.out.println(result.getInt(\"id\") + \"\\t\" + result.getString(\"name\") + \"\\t\" + result.getString(\"password\") + \"\\t\\t\" + result.getInt(\"age\") + \"\\t\" + result.getInt(\"sex\")); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 7. 关闭连接 if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"技术类","slug":"技术类","permalink":"http://jeson.org/categories/技术类/"}],"tags":[{"name":"java","slug":"java","permalink":"http://jeson.org/tags/java/"},{"name":"JDBC","slug":"JDBC","permalink":"http://jeson.org/tags/JDBC/"}]},{"title":"Android中常用的第三方框架","slug":"Android常用框架","date":"2017-04-22T16:00:00.000Z","updated":"2017-05-13T10:59:22.495Z","comments":true,"path":"2017/04/23/Android常用框架/","link":"","permalink":"http://jeson.org/2017/04/23/Android常用框架/","excerpt":"","text":"Android中常用的第三方框架缓存 名称 描述 DiskLruCache Java实现基于LRU的磁盘缓存 图片加载 名称 描述 Android Universal Image Loader 一个强大的加载，缓存，展示图片的库 Picasso 一个强大的图片下载与缓存的库 Fresco 一个用于管理图像和他们使用的内存的库 Glide 一个图片加载和缓存的库 图片处理 名称 描述 Picasso-transformations 一个为Picasso提供多种图片变换的库 Glide-transformations 一个为Glide提供多种图片变换的库 Android-gpuimage 基于OpenGL的Android过滤器 网络请求 名称 描述 Android Async HTTP Android异步HTTP库 AndroidAsync 异步Socket，HTTP(客户端+服务器)，WebSocket，和socket.io库。基于NIO而不是线程。 OkHttp 一个Http与Http/2的客户端 Retrofit 类型安全的Http客户端 Volley Google推出的Android异步网络请求框架和图片加载框架 网络解析 名称 描述 Gson 一个Java序列化/反序列化库，可以将JSON和java对象互相转换 Jackson Jackson可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象 Fastjson Java上一个快速的JSON解析器/生成器 HtmlPaser 一种用来解析单个独立html或嵌套html的方式 Jsoup 一个以最好的DOM，CSS和jQuery解析html的库 数据库 名称 描述 OrmLite JDBC和Android的轻量级ORM java包 Sugar 用超级简单的方法处理Android数据库 GreenDAO 一种轻快地将对象映射到SQLite数据库的ORM解决方案 ActiveAndroid 以活动记录方式为Android SQLite提供持久化 SQLBrite SQLiteOpenHelper 和ContentResolver的轻量级包装 Realm 移动数据库：一个SQLite和ORM的替换品 依赖注入 名称 描述 ButterKnife 将Android视图和回调方法绑定到字段和方法上 Dagger2 一个Android和java快速依赖注射器。 AndroidAnotations 快速安卓开发。易于维护 RoboGuice Android平台的Google Guice 图表 名称 描述 WilliamChart 创建图表的Android库 HelloCharts 兼容到API8的Android图表库 MPAndroidChart 一个强大的Android图表视图/图形库 后台处理 名称 描述 Tape 一个轻快的，事务性的，基于文件的FIFO的库 Android Priority Job Queue 一个专门为Android轻松调度任务的工作队列 事件总线 名称 描述 EventBus 安卓优化的事件总线，简化了活动、片段、线程、服务等的通信 Otto 一个基于Guava的增强的事件总线 响应式编程 名称 描述 RxJava JVM上的响应式扩展 RxJavaJoins 为RxJava提供Joins操作 RxAndroid Android上的响应式扩展，在RxJava基础上添加了Android线程调度 RxBinding 提供用RxJava绑定Android UI的API Agera Android上的响应式编程 Log框架 名称 描述 Logger 简单，漂亮，强大的Android日志工具 Hugo 在调试版本上注解的触发方法进行日志记录 Timber 一个小的，可扩展的日志工具 测试框架 名称 描述 Mockito Java编写的Mocking单元测试框架 Robotium Android UI 测试 Robolectric Android单元测试框架 Android自带很多测试工具：JUnit，Monkeyrunner，UiAutomator，Espresso等 调试框架 名称 描述 Stetho 调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试 性能优化 名称 描述 LeakCanary 内存泄漏检测工具 ACRA Android应用程序崩溃报告","categories":[{"name":"参考类","slug":"参考类","permalink":"http://jeson.org/categories/参考类/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jeson.org/tags/Android/"},{"name":"框架","slug":"框架","permalink":"http://jeson.org/tags/框架/"}]},{"title":"Android群英传-笔记","slug":"笔记-Android群英传","date":"2017-04-22T16:00:00.000Z","updated":"2017-05-13T11:02:04.056Z","comments":true,"path":"2017/04/23/笔记-Android群英传/","link":"","permalink":"http://jeson.org/2017/04/23/笔记-Android群英传/","excerpt":"","text":"大色块使用 Material Design 主题 Palette 提取颜色 依赖：com.android.support:palette-v7:21.0.2 elevation 阴影 xml--&gt;elevation Tinting 着色 xml--&gt;tint/tintMode Clipping 裁剪 java--&gt; ViewOutlineProvider vopCircle = new ViewOutlineProvider() { @Override public void getOutline(View view, Outline outline) { outline.setOval(0, 0, view.getWidth(), view.getHeight()); } }; cicle.setOutlineProvider(vopCircle); 注意：背景会覆盖裁剪 RecyclerView 列表 依赖：com.android.support:recyclerview-v7:21.0.2 RecyclerView.Adapter CardView 卡片 依赖：com.android.support:cardview-v7:23.0.1 xml--&gt; (1) xmlns:cardview=&quot;http://schemas.android.com/apk/res-auto&quot; (2) cardview:cardBackgroundColor=&quot;#aaf&quot; (3) cardview:cardCornerRadius=&quot;8dp&quot; 过渡动画 Explode/Slide/Fade ActivityA: java--&gt;startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this).toBundle()); ActivityB: java--&gt; getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); getWindow().setEnterTransition(new Explode()); getWindow().setExitTransition(new Slide()); 共享元素ActivityA: java--&gt; startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, Pair.create(view,&quot;fab&quot;)).toBundle()); startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, view,&quot;fab&quot;).toBundle()); XMLB–&gt; android:transitionName=&quot;fab&quot; Ripple波纹效果 有界：android:backgroud=&quot;?android:attr/selectableItemBackgroud&quot; 无界：android:backgroud=&quot;?android:attr/selectableItemBackgroudBorderless&quot; XML–&gt; &lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:color=&quot;#faa&quot;&gt; &lt;!--可省略--&gt; &lt;item&gt; &lt;shape android:shape=&quot;oval&quot;&gt; &lt;solid android:color=&quot;#aaf&quot;&gt;&lt;/solid&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/ripple&gt; Circular Reveal圆形展示 final Animator animator; imageView.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { if(animator!=null &amp;&amp; animator.isRunning()){ return false; } animator = ViewAnimationUtils.createCircularReveal(imageView, (int) event.getX(),(int) event.getY(), 0, (float) Math.hypot(imageView.getWidth(), imageView.getHeight())); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.setDuration(1000); animator.start(); return false; } }); StateListAnimatorjava–&gt; imageView.setStateListAnimator(AnimatorInflater.loadStateListAnimator(this,R.drawable.state_selector)); state_selector.XML–&gt; &lt;ImageButton android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@mipmap/ic_launcher&quot; android:stateListAnimator=&quot;@drawable/state_selector&quot;/&gt; selector.XML–&gt; &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_pressed=&quot;true&quot;&gt; &lt;set&gt; &lt;objectAnimator android:propertyName=&quot;rotationY&quot; android:duration=&quot;1000&quot; android:valueTo=&quot;30&quot; android:pivotY=&quot;0&quot; android:valueType=&quot;floatType&quot;/&gt; &lt;/set&gt; &lt;/item&gt; &lt;item&gt; &lt;set&gt; &lt;objectAnimator android:propertyName=&quot;rotationY&quot; android:duration=&quot;1000&quot; android:valueTo=&quot;0&quot; android:pivotY=&quot;0&quot; android:valueType=&quot;floatType&quot;/&gt; &lt;/set&gt; &lt;/item&gt; &lt;/selector&gt; animated-selector 5.X新特性 --&gt;P290 无法复现 Toolbar 代替ActionBar compile &apos;com.android.support:appcompat-v7:21.0.3&apos; --&gt;P294 无法复现================================================ java--&gt; toolbar= (Toolbar) findViewById(android.R.id.toolbar); toolbar.setLogo(R.mipmap.ic_launcher); toolbar.setTitle(&quot;主标题&quot;); toolbar.setSubtitle(&quot;副标题&quot;); setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); mDrawerLayout= (DrawerLayout) findViewById(R.id.drawer); mDrawerToggle = new ActionBarDrawerToggle(this,mDrawerLayout, toolbar, R.string.abc_action_bar_home_description,R.string.abc_action_bar_home_description_format); mDrawerToggle.syncState(); mDrawerLayout.setDrawerListener(mDrawerToggle); style.XML--&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;#4876FF&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;#3A5FCD&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/white&lt;/item&gt; &lt;item name=&quot;android:searchViewStyle&quot;&gt;@style/MySearchView&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;MySearchView&quot; parent=&quot;Widget.AppCompat.SearchView&quot;&gt;&lt;/style&gt; DrawerLayout 侧滑菜单--&gt; &lt;android.support.v4.widget.DrawerLayout android:id=&quot;@+id/drawer&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/holo_blue_light&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;内容界面&quot;/&gt; &lt;/LinearLayout&gt; &lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; &gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:background=&quot;@android:color/holo_blue_light&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;200dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;菜单界面_1&quot;/&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; &lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;end&quot; &gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;end&quot; android:background=&quot;@android:color/holo_blue_light&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;200dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;菜单界面_2&quot;/&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; Notification通知折叠式 notification.contentIntent = RemoteViews; 展开式 notification.bigContentView = RemoteViews; 悬挂式 builder.setFullScreenIntent(pendingIntent, true); 等级式 builder.setVisibility(Notification.VISIBILITY_PUBLIC); Layer 图层 XML--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/ic_launcher&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/ic_launcher&quot; android:left=&quot;20dip&quot; android:right=&quot;20dip&quot; android:bottom=&quot;20dip&quot; android:top=&quot;20dip&quot;&gt;&lt;/item&gt; &lt;/layer-list&gt; Java--&gt; Paint p =new Paint(); p.setColor(Color.RED); canvas.drawCircle(getWidth()/3,getHeight()/3,getWidth()/2,p); canvas.saveLayerAlpha(0, 0 , getWidth() ,getHeight(),127); &lt;---- p.setColor(Color.GREEN); canvas.drawCircle(getWidth()*2/3,getHeight()*2/3,getWidth()/2,p); canvas.restore(); Bitmap XML--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;@drawable/ic_launcher&quot;&gt; &lt;/bitmap&gt; ViewStub可以在XML中插入标签，在初次渲染时不会填充这个控件只能调用一次inflate()方法，因为调用一次后，viewStub就变为了指定的控件 XML12345&lt;ViewStub android:id=&quot;@+id/view_stub&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout=&quot;@layout/activity_main&quot;/&gt; java123ViewStub viewStub = (ViewStub) findViewById(R.id.view_stub);//viewStub.setVisibility(View.VISIBLE);LinearLayout ll = (LinearLayout) viewStub.inflate(); 色彩特效色彩矩阵分析 色调–物体传播的颜色 饱和度–颜色的纯度，从0（灰）到100%（饱和）来进行描述 亮度–颜色的相对明暗程度 颜色矩阵ColorMatrix 4X5数字矩阵 处理色调 cm.setRotate() 处理饱和度cm.setSaturation() 处理亮度cm.setScale(); 例1234567891011121314151617Paint p =new Paint();Bitmap bm = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher);Bitmap bmp = Bitmap.createBitmap(bm);ColorMatrix cm = new ColorMatrix();//指定颜色矩阵数值4X5，灰度效果float[] matrix = &#123; 0.33f,0.59f,0.11f,0,0, 0.33f,0.59f,0.11f,0,0, 0.33f,0.59f,0.11f,0,0, 0, 0, 0, 1,0&#125;;cm.set(matrix);ColorMatrix cm2 = new ColorMatrix();cm2.setScale(1f,1f,0f,1);cm.postConcat(cm2);p.setColorFilter(new ColorMatrixColorFilter(cm));canvas.drawBitmap(bmp,0,0,p); 图形特效变形矩阵Matrix 3X3数字矩阵 前乘和后乘是不同的运算，影响变换的顺序12m.postXXX();m.preXXX(); 图形变换 平移变换1m.setTranslate(); 123| 1 0 Δx || 0 1 Δy || 0 0 1 | 旋转变换1m.setRotate(); 123| cosα -sinα 0 || sinα cosα 0 || 0 0 1 | 缩放变换1m.setScale(); 123| k1 0 0 || 0 k2 0 || 0 0 1 | 错切变换1m.setSkew(); 123| 1 k1 0 || k2 1 0 || 0 0 1 | 像素块分析/** * WIDTH 像素块的横向个数 * HEIGHT 像素块的纵向个数 * verts 分割线的交叉点坐标数组，包括与边界的交叉点，长度为 （WIDTH + 1）*（HEIGHT + 1）*2 * / canvas.drawBitmapMesh(bitmap,WIDTH,HEIGHT,verts,0,null,0,null); 例1234567891011121314151617181920212223242526272829303132333435363738394041424344public MyTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); init();&#125;private final int WIDTH = 200;private final int HEIGHT = 200;private Bitmap bm = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher);private float mWidth;private float mHeight;private float[] orig = new float[(WIDTH+1)*(HEIGHT+1)*2];private float[] verts = new float[(WIDTH+1)*(HEIGHT+1)*2];private void init()&#123; mWidth=bm.getWidth(); mHeight=bm.getHeight(); float dx = mWidth/WIDTH; float dy = mHeight/HEIGHT; for (int y=0;y&lt;=HEIGHT;y++)&#123; for (int x=0;x&lt;=WIDTH;x++)&#123; int index = (WIDTH+1)*y+x; orig[index*2]=verts[index*2]=dx*x; orig[index*2+1]=verts[index*2+1]=dy*y+100; &#125; &#125;&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; wave(); canvas.drawBitmapMesh(bm,WIDTH,HEIGHT,verts,0,null,0,null); super.onDraw(canvas); invalidate();&#125;private double k;private final int A = 10;private void wave()&#123; for (int y=0;y&lt;=HEIGHT;y++)&#123; for (int x=0;x&lt;=WIDTH;x++)&#123; int index = (WIDTH+1)*y+x; verts[index*2] = orig[index*2]+getMeasuredWidth()/2-bm.getWidth()/2; float dy = (float) Math.sin(2*Math.PI/WIDTH*x + Math.PI*k); verts[index*2+1]=orig[index*2+1]+dy*A; &#125; &#125; k+=0.1f;&#125; 画笔特效（极其重要）PorterDuffXfermode遮盖效果1mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); 更好的效果可以使用贝塞尔曲线，当前只使用圆滑效果12345mPaint.setStyle(Paint.Style.STROKE);mPaint.setStrokeJoin(Paint.Join.ROUND);mPaint.setStrokeWidth(100);mPaint.setStrokeCap(Paint.Cap.ROUND);mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); 注意： 最好关闭在绘图时关闭硬件加速，有些模式不支持硬件加速 例：12345678910111213141516171819private void init()&#123; //低层的就是dst，上层的就是src src = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher); dst =Bitmap.createBitmap(src.getWidth(),src.getHeight(), Bitmap.Config.ARGB_8888); mCanvas = new Canvas(dst); mPaint = new Paint(); mPaint.setColor(Color.RED); mCanvas.drawCircle(src.getWidth()/2,src.getHeight()/2,src.getHeight()/3,mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); mCanvas.drawBitmap(src,0,0,mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT)); mCanvas.drawCircle(src.getWidth()/2,src.getHeight()/2,src.getHeight()/10,mPaint);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(dst,0,0,null);&#125; Shader着色器，渲染器实现一系列的渐变和渲染效果 Shader BitmapShader–位图Shader LinearGradient–线性Shader RadialGradient–光束Shader SweepGradient–梯度Shader ComposeShader–混合Shader 例–LinearGradient：123456@Overrideprotected void onDraw(Canvas canvas) &#123; mPaint.setShader(new LinearGradient(0,0,getMeasuredWidth(),0,Color.RED,Color.GREEN, Shader.TileMode.MIRROR)); canvas.drawRect(0,0,getMeasuredWidth(),getMeasuredHeight(),mPaint); super.onDraw(canvas);&#125; 例–PorterXfermode和Shader混合使用：12345678910111213141516171819private void init()&#123; src = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher); Matrix matrix = new Matrix(); matrix.setScale(1f,-1f); dust = Bitmap.createBitmap(src,0,0,src.getWidth(),src.getHeight(),matrix,true); mPaint = new Paint(); mPaint.setShader(new LinearGradient(0,src.getHeight(),0,src.getHeight()*2,0xFF000000,0xffffffff, Shader.TileMode.CLAMP));&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int saveCount = canvas.saveLayer(0,0,getMeasuredWidth(),getMeasuredHeight(),null,Canvas.ALL_SAVE_FLAG &amp; (~Canvas.CLIP_SAVE_FLAG)); canvas.drawBitmap(src,0,0,null); canvas.drawBitmap(dust,0,src.getHeight(),null); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawRect(0,src.getHeight(),src.getHeight(),src.getHeight()*2,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(saveCount); PathEffect路径效果 null无效果 CornerPathEffect将拐角变得圆滑 DisctetePathEffect线段上有很多的杂点 DashPathEffect绘制虚线，可以控制每个点的间隔 PathDashPathEffectDashPathEffect增强版，可以设置点的样式，矩形，圆点等 ComposePathEffect组合方式 例：12345678910111213141516171819202122232425262728293031323334353637public class MyPathView extends View&#123; private Path mPath; private PathEffect[] mPathEffects = new PathEffect[6]; private Paint mPaint; public MyPathView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPath = new Path(); mPath.moveTo(0,200); for(int i=1;i&lt;50;i++)&#123; mPath.lineTo(i*20, (float) (Math.random()*100)+200); &#125; mPaint = new Paint(); mPaint.setColor(Color.parseColor(&quot;#000000&quot;)); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(5); mPathEffects[0] = null; mPathEffects[1] = new CornerPathEffect(30); mPathEffects[2] = new DiscretePathEffect(3f,5f); mPathEffects[3] = new DashPathEffect(new float[]&#123;50f,10f,5f&#125;,0); Path path = new Path(); path.addRect(0,0,8,8,Path.Direction.CCW); mPathEffects[4] = new PathDashPathEffect(path,12,0,PathDashPathEffect.Style.ROTATE); mPathEffects[5] = new ComposePathEffect( mPathEffects[3], mPathEffects[1]); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(); for (int i = 0 ;i&lt; mPathEffects.length;i++)&#123; mPaint.setPathEffect(mPathEffects[i]); canvas.drawPath(mPath,mPaint); canvas.translate(0, 200); &#125; canvas.restore(); &#125;&#125; 效果图如下 PathEffect 动画布局动画LinearLayout 例123456LinearLayout ll = (LinearLayout) findViewById(R.id.ll);ScaleAnimation sa = new ScaleAnimation(0, 1, 0, 1);sa.setDuration(2000);LayoutAnimationController lac = new LayoutAnimationController(sa, 0.5f);lac.setOrder(LayoutAnimationController.ORDER_RANDOM);ll.setLayoutAnimation(lac); SVG","categories":[{"name":"技术类","slug":"技术类","permalink":"http://jeson.org/categories/技术类/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jeson.org/tags/Android/"},{"name":"Android群英传","slug":"Android群英传","permalink":"http://jeson.org/tags/Android群英传/"}]},{"title":"笔记-MYSQL使用","slug":"笔记-MySQL使用","date":"2017-04-19T16:00:00.000Z","updated":"2017-05-13T14:07:20.576Z","comments":true,"path":"2017/04/20/笔记-MySQL使用/","link":"","permalink":"http://jeson.org/2017/04/20/笔记-MySQL使用/","excerpt":"","text":"MYSQL学习笔记 MYSQL提示符 prompt \\u 参数 描述 \\D 完整的日期 \\d 当前数据库 \\h 服务器名称 \\u 当前用户名 MYSQL语句规范 关键字和函数名全部大写 数据库名称,表名称,字段名称全部小写 SQL语句必须以;结尾 MYSQL数据类型整型 数据类型 存储字节 TINYINT 1 SMALLINT 2 MEDIUMINT 3 INT 4 BIGINT 8 浮点型 数据类型 存储字节 FLOAT[(M, D)] 4 DOUBLE[(M, D)] 8 日期 日期类型 范围 YEAR 年份yyyy TIME 时间(hh-mm-ss) DATE 日期(yyyy-mm-dd) DATETIME 日期与时间組合(yyyy-mm-dd hh-mm-ss) TIMESTAMP yyyymmddhhmmss 字符串 数据类型 最大长度 CHAR(M) 255 VARCHAR(M) 255 TINYTEXT 255 TEXT 65535 MEDIUMTEXT 2^24 - 1 LONGTEXT 2^32 - 1 ENUM(‘value1’, ‘value2’, …) 集合最大数目为65535 SET(‘value1’, ‘value2’, …) 集合最大数目为64 MYSQL常用命令常用mysql数据库信息显示当前服务器版本 SELECT VERSION(); 显示当前日期 SELCET NOW(); 显示当前用户 SELECT USER(); 查看打开的数据库 SELECT DATABASE(); 查找记录 SELECT FROM expr, ... FROM tbl_name; 打开数据库 USE db_name; 查看数据库/表信息查看服务器下的数据库列表 SHOW {DATABASES | SCHEMA} [LIKE &#39;pattern&#39; | WHERE expr]}; 查看创建数据库的语句以及编码方式 SHOW CREATE DATABASE db_name; 查看(当前)数据库的数据表 SHOW TABLES [FROM db_name] [LIKE &#39;pattern&#39; | WHERE expr]; 查看数据表的结构 SHOW COLUMNS FROM tbl_name; 查看索引 SHOW INDEXES FROM provinces[\\G]; 设置编码方式 SET NAMES GBK; 创建数据库/表创建数据库 CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] character_name; 创建数据表 CREATE TABLE [IF NOT EXISTS] jeson( id INT UNSIGNED, name VARCHAR(30), age TINYINT UNSIGNED, salary FLOAT(8,2) UNSIGNED ); 创建带有外键的数据表 先创建父表 CREATE TABLE provinces (id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, name VARCHAR(30) NOT NULL); 创建子表 CREATE TABLE users(id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, name VARCHAR(30) NOT NULL,pid SMALLINT UNSIGNED, FOREIGN KEY (pid) REFERENCES provinces (id)); 修改数据表修改数据的编码方式 ALTER {DATABASE | SCHEMA} [db_name] [DEFAULT] CHARACHTER SET [=] character_name; 修改数据表名称 ALTER TABLE tbl_name RENAME [TO | AS] new_tbl_name; RENAME TABLE tbl_name TO new_tbl_name [, tbl_name2 TO new_tbl_name2, ...] 添加单列, 可以指定列的位置 ALTER TABLE tbl_name ADD [COLUMN] col_name col_definition [FIRST | AFTER col_name]; 添加多列, 不可以指定列的位置 ALTER TABLE tbl_name ADD [COLUMN] (col_name1 col_definition , col_name2 col_definition, ...); 删除一列或多列 ALTER TABLE tbl_name DROP [COLUMNS] col_name [, DROP [COLUMNS] col_name1, DROP [COLUMNS] col_name2, ...]; 添加主键约束, 只能有一个 ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name, ...); 添加唯一约束, 可以有多个 ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name, ...); 添加外键约束 ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name, ...) REFERENCES tbl_name (index_col_name); 添加/删除默认约束 ALTER TABLE tbl_name ALTER [COLUMNS] COL_NAME {SET DEFAULT literal | DROP DEFAULT}; 删除主键约束 ALTER TABLE tbl_name DROP PRIMARY KEY; 删除唯一约束 ALTER TABLE tbl_name DROP {INDEX | KEY} index_name; 删除外键约束 ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol; 修改列定义, 数据类型从大类型改为小类型时会造成数据丢失 ALTER TABLE tbl_name MODIFY [COLUMNS] col_name col_definition [FIRST | AFTER col_name]; 修改列名称, 也包含列定义的功能 ALTER TABLE tbl_name CHANGE [COLUMNS] old_col_name new_col_name col_definition [FIRST | AFTER col_name]; 删除数据库/表/记录删除数据库 DROP {DATABASE | SCHEMA} [IF EXISTS] db_name; 删除数据表 DROP TABLE [IF EXISTS] tbl_name; 删除数据表中的记录 DELETE FROM provinces WHERE id = 3; 向数据表插入记录 INSERT [INTO] tabl_name [(col_name, ...)] VALUES(val, ...); 字段约束字段创建时约束 NULL 默认值可以为空 NOT NULL 默认值不可以为空 AUTO_INCREMENT 自动编号, 且必须与主键组合使用 默认情况下起始值为1, 每次的增量为1 PRIMARY KEY 主键约束 每张表只能存在一个主键 主键保证记录的唯一性 主键自动为NOT NULL UNIQUE KEY 唯一约束 每张数据表可以存在多个唯一约束 唯一约束可以保证记录的唯一性 唯一约束的字段可以为NULL DEFAULT 字段的默认值 FOREIGN KEY 保持数据一致性, 完整性 实现一对一或一对多的关系 外键约束的要求 父表和子表必须使用相同的存储引擎, 而且禁止使用临时表 数据表的存储引擎只能为INNODB 外检列和参照列必须具有相似的数据类型. 其中数字的长度或者是否有符号位必须相同; 而字符的长度则可以不同 外键列和参照列必须创建索引. 如果外键列不存在索引的话, MySQL将自动创建索引 外键约束的参照操作 CASCADE 从父表删除或更新时, 自动删除或更新子表中匹配的行 SET NULL 从父表删除或更新时, 自动设置子表中的外键列为NULL, 如果使用该选项, 必须保证子表列没有指定NOT NULL RESTRICT 拒绝对父表的删除或更新操作 NO ACTION 标准的SQL关键字, 与RESTRICT相同 例: 1234567891011CREATE TABLE provinces( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, name VARCHAR(30) NOT NULL);CREATE TABLE users( id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, name VARCHAR(30) NOT NULL, pid SMALLINT UNSIGNED, FOREIGN KEY (pid) REFERENCES provinces (id) ON DELETE CASCADE); 表级约束和列级约束&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列级约束既可以在列定义时声明, 也可以在列定义后声明; 表级约束只能在列定义后声明. 表级约束 对一个数据列建立的约束, 开发中经常使用 表级约束 对多个数据列建立的约束 记录操作插入记录 INSERT [INTO] tbl_name [(col_name, ...)] {VALUES | VALUE} ({expr | DEFAULT}, ...),(...),...; 插入时主键可以使用NULL或者DEFALUT使用自动的默认值 拥有默认值得字段可以使用DEFAULT 可以在VALUES后加多个记录 可以在值中加入函数 例: 123INSERT users VALUES (DEFAULT, &apos;zhangsan&apos;, &apos;1230&apos;, 20*8-100, &apos;1&apos;), (NULL, &apos;lisi&apos;, md5(&apos;123&apos;), DEFAULT, 2); INSERT [INTO] tbl_name SET col_name={expr | DEFAULT}, ...; 与第一种方式区别在于, 此方法可以使用子查询 一次性只能插入一条数据 INSERT [INTO] tbl_name [(col_name, ...)] SELECT ...; 此方法可以将查询结果插入到指定的数据表中 更新记录 单表更新 INSERT [LOW_PRIORUTY] [IGNORE] tbl_reference SET col_name1={expr | DEFAULT} [, col_name2={expr2|DEFAULT}] ... [WHERE where_condition]; 例: 1UPDATE users SET age = age + 10 WHERE id % 2 =0; 多表更新 UPDATE tbl_references SET col_name1 ={expr1 | DEFAULT} [, col_name2={expr2 | DEFAULT}], ... [WHERE where_condition]; 语法结构 tbl_reference {[INNER | CROSS] JOIN | {LEFT | RIGHT} [OUTER] JOIN} tbl_reference ON conditional_expr; 例:1UPDATE goods INNER JOIN category ON goods_cate=name SET goods_cate=id; 删除记录 单表删除 DELETE FROM tbl_name [WHERE where_condition]; 多表删除 DELETE tbl_name[.*] [, tbl_name[.*]] ... FROM tbl_references [WHERE where_condition] 例: 删除自身重复的数据1234DELETE t1 FROM goods AS t1 LEFT JOIN (SELECT MIN(goods_id) goods_id, goods_name FROM goods GROUP BY goods_name HAVING COUNT(goods_name)&gt;= 2) AS t2 ON t1.goods_name = t2.goods_name WHERE t1.goods_id &lt; t2.goods_id; 查找记录 123456789SELECT select_expr [, select_expr2, ...][ FROM tbl_references [WHERE where_condition] [GROUP BY &#123;col_name | position&#125; [ASC | DESC], ...] [HAVING where_condition] [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC], ...] [LIMIT &#123;[offset, ] row_count | row_count OFFSET offset&#125;]]; 查询表达式 每一个表达式表示想要的一列, 必须至少有一个 多个列之间以英文逗号分隔 星号*表示所有列, tbl_name.* 可以表示命名表的所有列 查询表达式可以使用[ AS ] alias_name为其赋予别名 别名可用于GROUP BY, ORDER BY, HAVING子句 条件表达式 WHERE expr; 对记录进行过滤, 如果没有指定WHERE子句, 则显示所有子句 在WHERE表达式中,可以使用MySql支持的函数或运算符 查询结果分组 [GROUP BY {col_name | position} [ASC | DESC], ...]; 分组条件 [HAVING where_condition]; 根据部分记录进行分组 条件必须出现在分组条件所选择的字段或者是聚合函数,如count() 对查询结果进行排序 [ORDER BY {col_name | expr | position} [ASC | DESC], ...]; 限制查询结果返回的数量 [LIMIT {[offset, ] row_count | row_count OFFSET offset}]; 查询操作子查询 子查询(Subquery)是指出现在其他SQL语句内的SELECT子句 子查询指嵌套在查询内部, 且必须始终出现在圆括号内 子查询可以包含多个关键字或条件, 如DISTINCT,GROUP BY, ORDER BY, LIMIT, 函数等 子查询的外层查询可以是:SELECT, INSERT, UPDATE, SET, DO等 子查询可以返回标量, 一行, 一列或者子查询 例: 1SELECT * FROM tb_name1 WHERE col_name1 = (SELECT col_name2 FROM tbl_name2); 分类使用比较运算符的子查询= &gt; &lt; &gt;= &lt;= &lt;&gt; != &lt;=&gt; 用ANY SOME ALL修饰的比较运算符 运算符 \\ 关键字 ANY SOME ALL &gt;, &gt;= 最小值 最小值 最大值 &lt;, &lt;= 最大值 最大值 最小值 = 任意值 任意值 &lt;&gt;, != 任意值 例: 1SELECT goods_name,brand_name, goods_price FROM goods WHERE goods_price &lt;= ALL(SELECT goods_price FROM goods WHERE goods_cate = &apos;超级本&apos;); 使用IN, NOT IN的子查询IN 作用等同于 =ANY() NOT IN 作用等同于 !=ALL() 使用NOT EXIST, EXIST的子查询如果子查询返回任何行, EXIST则返回TRUE, 否则为FALSE 将查询结果插入到数据表1INSERT [INTO] tbl_name [(col_name, ...)] SELECT ... 例:1INSERT category (name) (SELECT brand_name FROM goods); 创建表的同时将查询结果写入到数据表1CREATE TABLE [IF NOT EXIST] tbl_name [(create_definition, ...)] select_statement; 例:12345CREATE TABLE brands ( id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, brand_name VARCHAR(40) NOT NULL)(SELECT brand_name FROM goods GROUP BY brand_name); 连接tbl_reference {[INNER | CROSS] | { LEFT | RIGHT} [OUTER]} JOIN tbl_reference ON confitional_expr 内连接INNER JOIN/JOIN/CROSS JOIN交集, 显示左表和右表符合连接条件的记录 例:1SELECT goods_id, goods_name, cate_name FROM goods INNER JOIN category ON goods.cate_id=category.cate_id; 左外连接LEFT [OUTER] JOIN显示左表的全部记录及右表符合连接条件的记录1SELECT goods_id, goods_name, cate_name FROM goods LEFT JOIN category ON goods.cate_id=category.cate_id; 右外连接RIGHT [OUTER] JOIN显示右表的全部记录及左表符合连接条件的记录1SELECT goods_id, goods_name, cate_name FROM goods RIGHT JOIN category ON goods.cate_id=category.cate_id; 连接条件ON或者WHERE通常使用ON关键字来设定连接条件, 使用WHERE关键字进行结果集记录的过滤 多表连接tbl_reference ({[INNER | CROSS] | { LEFT | RIGHT} [OUTER]} JOIN tbl_reference ON confitional_expr) * n 自身连接 例: 1SELECT c.type_id,c.type_name,p.type_name FROM tdb_goods_types c LEFT JOIN tdb_goods_types p ON c.parent_id=p.type_id; 1SELECT p.type_id,p.type_name,c.type_name FROM tdb_goods_types p LEFT JOIN tdb_goods_types c ON c.parent_id=p.type_id; 1SELECT p.type_id,p.type_name,COUNT(c.type_name) FROM tdb_goods_types p LEFT JOIN tdb_goods_types c ON c.parent_id=p.type_id GROUP BY p.type_id; 无限级数据表设计 例:12345CREATE TABLE tdb_goods_types( type_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, type_name VARCHAR(20) NOT NULL, parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0); 函数字符函数 函数名称 描述 CONCAT() 字符连接 CONCAT_WS() 使用指定的分隔符进行字符连接 FORMAT() 数字格式化, 返回值为字符型 LOWER() 转换成小写字母 UPPER() 转换成大写字母 LEFT() 获取左侧n个字符 RIGHT() 获取右侧n个字符 LENGTH() 获取字符串的长度 LTRIM() 删除前导空格 RTRIM() 删除后续空格 TRIM() 删除前导和后续空格 SUBSTRING() 字符串截取 [NOT] LIKE 模式匹配 REPLACE() 字符串替换 例: CONCAT() 12SELECT CONCAT(&apos;HELLO&apos;, &apos; &apos;, &apos;WORLD&apos;);SELECT CONCAT(firstname, lastname) as fullname FROM users; 例: CONCAT_WS() 1SELECT CONCAT_WS(&apos;.&apos;, &apos;firstname&apos;, &apos;lastname&apos;); 例: FORMAT() 1SELECT FORMAT(123456.7890, 2); 例: LOWER()``UPPER() 12SELECT LOWER(&apos;HELLO WORLD&apos;);SELECT UPPER(&apos;hello world&apos;); 例: LEFT()``RIGHT() 12SELECT LEFT(&apos;HELLO&apos;, 2);SELECT RIGHT(&apos;WORLD&apos;, 2); 例: TRIM() 123SELECT TRIM(LEADING &apos;!&apos; FROM &apos;!! hello world !!&apos;); //删除前导 !SELECT TRIM(TRAILING&apos;!&apos; FROM &apos;!! hello world !!&apos;); //删除后续 !SELECT TRIM(BOTH&apos;!&apos; FROM &apos;!! hello world !!&apos;); //删除前导和后续 ! 例: REPLACE() 1SELECT REPLACE(&apos;!! hello !! world !!&apos;, &apos;!&apos;, &apos;?&apos;); 例: SUBSTRING() 12SELECT SUBSTRING(&apos;HELLO WORLD&apos;, 3);SELECT SUBSTRING(&apos;HELLO WORLD&apos;, 3, 6); 例: SUBSTRING() 1234SELECT SUBSTRING(&apos;HELLO WORLD&apos;, 3);SELECT SUBSTRING(&apos;HELLO WORLD&apos;, 3, 5);SELECT SUBSTRING(&apos;HELLO WORLD&apos;, -1);SELECT SUBSTRING(&apos;HELLO WORLD&apos;, -5, 2); //从尾部数第5个开始截取(包含), 截取2个 例: LIKE() 12SELECT &apos;MYSQL&apos; LIKE &apos;MY%&apos;; //%匹配零个至多个字符, _匹配一个字符, 返回值为trueSELECT &apos;MYSQL%&apos; LIKE &apos;%1%%&apos; ESCAPE &apos;1&apos;; //1后面的%不再认作通配符 数值运算符与函数 函数名称 描述 CEIL() 向上取整 FLOOR() 向下取整 ROUND() 四舍五入 DIV 整数除法 MOD 取余数(取模, %) POWER() 幂运算 TRUNCATE() 数字截取 [NOT] BETWEEN AND [不]在范围之内,闭合区间 [NOT] IN() [不]在列出值范围内 IS [NOT] NULL [不]为空 例: ROUND() 1SELECT ROUND(123456.789, 2); 例: TRUNCATE() 12SELECT TRUNCATE(123456.789, 2); //没有四舍五入SELECT TRUNCATE(123456.789, -1); 例: [NOT] BETWEEN AND 1SELECT 6 BETWEEN 2 AND 10; //左右都闭合的区间 例: IN() 1SELECT 6 IN(2, 4, 6, 8); 日期时间函数 函数名称 描述 NOW() 当前日期和时间 CURDATE() 当前日期 CURTIME() 当前时间 DATE_ADD() 日期变化 DATEDIFF() 日期差值 DATE_FORMAT() 日期格式化 例: DATE_ADD() 1SELECT DATE_ADD(CURDATE(), INTERVAL 365 DAY); 例: DATEDIFF() 1SELECT DATEDIFF(CURDATE(), &apos;2018-05-13&apos;); 例: DATE_FORMAT() 1SELECT DATE_FORMAT(CURDATE(), &apos;%m/%d/%Y&apos;); 信息函数 函数名称 描述 CONNECTION_ID() 连接ID DATABASE() 当前数据库 LAST_INSERT_ID() 最后插入记录的ID号 USER() 当前用户 VERSION() 版本信息 聚合函数返回值只有一个 函数名称 描述 AVG() 平局值 COUNT() 计数 MAX() 最大值 MIN() 最小值 SUM() 求和 加密函数 函数名称 描述 MD5() 信息摘要算法 PASSWORD() 密码算法, 常用于修改密码 例: MD5() 1SELECT MD5(&apos;admin&apos;); 例: PASSWORD() 12SELECT PASSWORD(&apos;admin&apos;);SET PASSWORD = PASSWORD(&apos;admin&apos;);","categories":[{"name":"技术类","slug":"技术类","permalink":"http://jeson.org/categories/技术类/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://jeson.org/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://jeson.org/tags/数据库/"}]},{"title":"程序员，你真的会写简历吗？","slug":"程序员，你真的会写简历吗？","date":"2017-02-28T16:00:00.000Z","updated":"2017-05-13T11:00:17.436Z","comments":true,"path":"2017/03/01/程序员，你真的会写简历吗？/","link":"","permalink":"http://jeson.org/2017/03/01/程序员，你真的会写简历吗？/","excerpt":"","text":"本文摘自慕课网，作者七月在夏天，程序员，你真的会写简历吗？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;又是一年跳槽季，金三银四毫不夸张。 简历是我们找工作的行头，重要性不言而喻。可你真的会写简历吗？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面试其实就是面试官和你的一次约会。他是女你是男，能不能在一起取决于你能否讨他的欢心。一份整洁的简历，重要性不亚于你约会时的行头和装束。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感谢这个时代简历不再需要手写，不然很多人的“字”都过不了关，比如说我，现在几乎是不会写字的。 简历是一个行业性和时代性很强的东西，不同的时代和行业简历的最优形态都不同，但一份好的简历总会有一些共同的特质。当然，简历只是“形”，真正重要的还是你个人的综合素质、业务能力以及技术水平。如果个人不具备很强的竞争力，那么简历就成了各大直播平台网红主播的封面照，只能在列表里看看，是万万不能点进去的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我不能说什么样的简历好，什么样的简历不好，每个简历审阅者都有自己的偏好。但我尝试从这些年看技术简历的经验中提取出一些我所关注的点，尝试和大家聊聊一份简历应该有的结构、细节、风格，以及一定不要有的内容。 简历这东西，说白了，就是你认真，他/她也认真。 整体风格&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，简历的第一要素是它必须要，简洁而不简单。这是整体风格。我们来看看整体风格上要注意哪些。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我看过很多同学的简历只有一页，字大行稀，这不好，3秒看完，还不知道你到底会干撒，这样的简历HR筛选简历这一关都过不了，根本到不了技术面试官手里；也看过很多简历，一页里密密麻麻的宋体4号字，这也不好，看的太累（但绝对比字大行稀要好）。通常来说选用宋体5号字，正文行间距在1.2左右。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正文不要有任何的加粗，只加粗标题（目的是为了让结构清晰）。各种在正文里加粗的作法会让面试者觉得太做作，自信的人是不需要特意强调某个关键字的，你的整体风格看起来清爽简介，简历筛选者自然会认真对待，并自己去寻找她需要的信息，根本无需加粗。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简历的页数很多文章推荐1到2页不超过3页，这说了和没说一样。我推荐的简历页数是2页，1页太少，3页太多，2页最佳。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要做彩色的简历（设计师除外）。只有黑白两色即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于研发岗位，不要附加照片，不要附加照片，不要附加照片，长的美不美、帅不帅都没有太多的好处。你根本不知道看简历的会不会嫉妒你的美貌。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简历的格式最好是PDF、PDF、PDF，重要的事情说3遍。很多人喜欢发Word，不是不行，但绝对没有一份PDF的看的舒服。一是PDF是只读模式，二是PDF打开更快速。Word这种东西，打开全屏的错别字检查，这体验简直是不能忍。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简历的文件命名请采用以下格式 姓名-电话-职位.pdf。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要在简历中写自己的微信号、QQ号。联系方式只留下一个邮箱和手机号即可。邮箱最好是163，outlook或者gmail，随意。qq邮箱这个怎么说吧，我个人认为是无所谓的，但遇到有些面试官就不好说了。 内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一份简历的结构非常的重要，基本上如果我至上到下扫一遍觉得结构非常混乱，不能让我对你有一个初步的了解，是不会继续往下看的，直接打回到HR那里。大家要知道每个人的时间都很宝贵，看简历的人没有义务为你的不认真买单。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的简历结构遵循以下的层次结构（并不是唯一结构，只是我推荐的一种）： 标题。标题只需要写XX的个人简历即可。 个人简介。个人简介包括姓名、毕业学校（大学以上）、年龄、出生年份（别写月日，看简历的不会想在你生日的时候给你一份惊喜）、学历、目前职位、籍贯、联系方式。要注意，这些内容通常都非常简单，不要每个属性单独一行，一行排3个属性最好。 工作经历。这是我很多同学完全忽略的地方，完全没有分清楚工作经历和项目经历。工作经历必须单独成为一块儿，每段经历不需要些太多，只需要以年份+公司名称+职位即可。比如 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2001~2003 xxx公司，PHP程序员 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2003~2005 xxx公司，架构师 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2005~2012 xxx公司，技术总监 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2012~2016 xxx公司，CTO &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这么简单即可，具体的工作内容是在项目经验里描述的。我推荐的就是这些内容，如果你还要加上薪资多少、公司规模等附加内容，我并不推荐，因为这些内容都是可以虚构的，写上去没有任何好处，反而会给简历阅读者一种无法掌控的心里暗示，他根本无法去核对这些信息。所以简历一定要尽可能的写一些容易实在的内容。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，时间一定要按照顺序排列，不要倒叙排列。这里是为了让简历阅读者看到你的履历，没有必要倒叙排列。时间最好能够接上，如果时间有中断，比如中间自己出去瞎折腾创业去了，想好怎么回答面试者的提问。80%的概念，提问者会问你中间这段时间干嘛去了。 相关技能。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要简单的罗列技术名词（这点太太太重要了），有些同学面试PHP岗位，技术名词从服务器到前端、从数据库到缓存、从PHP到Java，几乎我知道的技术名字他都写上去了。我一看工作年限，才不到3年。这样的简历，直接是被Pass的，对于一个正常智商水平的人来说，3年是不可能精通或者了解这么多技术和语言的。换句话说，如果你天赋异禀，我觉得你是不会投简历到我们这家小公司的，你早就是BAT、MS、Google的抢手货了。 推荐技术以Tech Stack技术栈的形式出现，形成一个系统，而不要东一个西一个，前端就是前端、服务器就是服务器，清清楚楚明明白白，即使你认为你是一个FullStack开发者，也请偏重一端，而不是两端齐头并进。你认为的Full Stack在很多有资历的技术开发者面前也许只是玩具，自娱自乐可以，但并不能应用到真实的生产环境中（真实环境有非常多的细节，一个非专业的开发者很难兼顾到所有细节）。所以，如果你要以 Full Stack的姿态出现在面试官面前，请三思。毕竟像模像样的公司，前端和服务器是区分非常严格的，专人专事儿才能做好一个产品。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，请慎重填写技术名词，最好每个技术名词附加一个更加详细的使用点。比如你说你懂Redis，那么请这样写：熟悉Redis的常规操作，对Redis五种数据类型、pub\\sub模式有较深入的理解，并将Redis应用在系统的缓存层以及秒杀系统中（如果你这样写，多半面试官会问你关于秒杀的细节，你就可以提前准备这方面的知识了）； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样写远比你把同类缓存系统全部罗列一边要好很多很多。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还要提醒大家，同类技术最好只写一个，很少有人能精通两个以上。比如对于Vue、Ng、React，我推荐事实求是。只选1个来写，精通AngularJS（然后按照上诉举例的Redis，写出其特性，比如AngularJS的指令、双向数据绑定等）。其实只写精通AngularJS即可，没有必要再补充一句“熟悉Vue”。简历阅读者要的是精通而非“泛”。而且，相信我，一个资深的技术总监，都相信一个真理，你精通一个框架再熟悉其他的框架并不是一个难事儿。你完全不需要担心我只会Vue，但公司要的是NG怎么办？这是没办法的办法，那么多框架，你能学得完？比如TP和Laravel，你精通一个另外一个真的不是什么太大的问题，但前提条件是，你！要！精！通！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;精通有点儿夸张，这个词在简历里已经被用烂了。事实上，严格意义上来讲，我们都只是能够很熟练的使用某个框架，要说到精通，个人认为等你把框架源代码看完了再来谈“精通”。所以，我认为是不是用精通这个词来描述技术，这取决于“精通”在你简历里出现的频度。如果你总共6项技能，4到5项都是精通、精通、精通、精通、精通，这很容易让你在面试的过程中相当的尴尬。合理分配精通、熟悉、了解这3个等级词汇的出现频度是非常重要的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外一个建议是，对于你不熟悉的只是知道是干什么的技术，千万不要写。很多面试者很喜欢找你只是简单提了一下的技术来发问，当然他并没有指望你能回答的多么准确，可如果哥们你一脸懵逼，完全不知道他说的是什么，应付几句的话都说不出来，那真的是得不偿失。如果你万一被问的懵逼了，请直接了当的说抱歉，这个我了解的并不深入，切忌东拉西扯，欲盖弥彰。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于前端同学来说，不要过多的描述CSS和HTML相关的能力。在很多公司眼里CSS和HTML是属于非常基础的能力，重要的是什么，重要的是JavaScript。如果你用JavaScript写过或者开发过任何框架性的东西，这是相当加分的。很多同学对于前端的理解还停留在“前端就是做页面”这个阶段，但事实上前端已经和服务器没有差别，大量复杂的业务需要前端来处理。这也是为什么这些年前端框架这么流行的原因，早期的网页哪儿有框架这个说法，一个Jquery走天下，更早的时候还有extjs这些，注意jquery只是一个库或者说工具，并不是框架。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结来说，CSS和HTML提一下即可，可以描述自己能够熟练使用LESS或者SASS。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个坑，如果你不是专业的DBA，切忌不要写精通MySQL，你根本不知道MySQL或者其他数据库精通是一个什么概念，随便问你几个数据库的锁机制你都答不上来，更何况很多同学连事务都没有使用过，只是简单的查询数据并不能说“精通MySQL”。当然，如果你应聘的是Web开发者，面试官也根本不会对你的MySQL要求有多高，会使用事务、能够很好的建立索引，避免过多的使用join查询，不会愚蠢的循环查询数据库即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多前端开发者喜欢附上自己个人作品，这个个人作品通常就是自己搭建的一个个人主页或者是博客，动效非常华丽，页面UI上佳，但相信我，HR筛选者看的都已经审美疲劳了。如果你的个人博客里没有什么有深度的技术文章，我并不建议附带这种纯粹的页面网页。原因还是在于我说的，你既然附上了作品，那么你肯定认为这是你最好的或者是最满意的。但你最好的最满意的作品，只是一个简单的效果网页，这会给面试官一种你根本不理解现在的前端是要做什么的感觉，他会潜意识的认为，你还停留在前端就是做网页这个阶段。得不偿失。当然，如果你有些博客的习惯，并且认真的对待每一篇的文章，那么无聊文章水平高低，都建议附加上。还有，不要附带自己的微信公众号在简历里，你是求职研发的，不是来做媒体的，这和技术不搭边。 项目经历、经验 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;切忌多而杂，很多同学，4,5页简历十几个项目，不管大项目、小项目统统都罗列出来，这非常的不好。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你需要挑选有代表性的项目，每个公司1到2个项目为佳。项目经验、描述把握一个原则，求质不求量。深度描述你在每个项目里的职责。推荐大家重点描述项目遇到了什么问题，你是如何解决的，或者是从业务、设计上巧妙规避或者是用什么技术来解决这个问题的。比如使用任务队列异步解耦订单的处理；使用Redis的pub\\sub来做定时器，避免长连接轮询；前端使用事件注册机制传递参数避免类与类之间的耦合等。一个项目里技术点太多了，选择你认为最重要或者你最得意的技术点来描述项目是非常好的做法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要在项目里机械的写出自己的职位，很多同学罗列十几个项目，每个项目都机械的写上项目经理、产品经理、程序员、小组长、负责人。没有必要。现在的公司都喜欢说自己是扁平化管理, 不建议强调自己在每个项目中的职位。你只需要写出你在项目中做了什么事情，解决了什么问题，深度描述你所使用的技术即可。其他的奇淫技巧根本不需要。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简历包括以上内容即可，如果你还有其他的比较有名气的开源项目可以附加上。我并不推荐杂七杂八的写一些个人的小作品，如果你在github上有一些高Star的开源项目，可以写上去，绝对是加分项。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，还是要提醒各位马上要换工作的同学，你的技术水平如何，一个稍微有资历的技术面试官问几个问题马上就能知道你的技术水平如何。所以，努力提升自己才是最重要的，如果你的技术功底深厚，不需要太多技巧简历也不会太差，但本文所提出的注意点并不属于技巧，而是一份优秀简历的基本要素。","categories":[{"name":"职场类","slug":"职场类","permalink":"http://jeson.org/categories/职场类/"}],"tags":[{"name":"简历","slug":"简历","permalink":"http://jeson.org/tags/简历/"},{"name":"职场","slug":"职场","permalink":"http://jeson.org/tags/职场/"}]},{"title":"第一行代码（第二版）","slug":"笔记-第一行代码（第二版）","date":"2016-12-31T16:00:00.000Z","updated":"2017-05-13T11:00:11.589Z","comments":true,"path":"2017/01/01/笔记-第一行代码（第二版）/","link":"","permalink":"http://jeson.org/2017/01/01/笔记-第一行代码（第二版）/","excerpt":"","text":"","categories":[{"name":"技术类","slug":"技术类","permalink":"http://jeson.org/categories/技术类/"}],"tags":[{"name":"android","slug":"android","permalink":"http://jeson.org/tags/android/"},{"name":"初学，android7.0","slug":"初学，android7-0","permalink":"http://jeson.org/tags/初学，android7-0/"}]},{"title":"Android源码设计模式解析与实战","slug":"笔记-Android源码设计模式解析与实战","date":"2016-11-30T16:00:00.000Z","updated":"2017-05-13T11:00:00.200Z","comments":true,"path":"2016/12/01/笔记-Android源码设计模式解析与实战/","link":"","permalink":"http://jeson.org/2016/12/01/笔记-Android源码设计模式解析与实战/","excerpt":"","text":"面向对象的六大原则稳定性 扩展性 健壮性 灵活性 高内聚 低耦合 1、单一职责原则一个类应该是一组相关性很高的函数、数据的封装。 2、开闭原则软件中的对象（类、模块、函数等）应该对扩展是开放的，对修改是封闭的。 3、里氏替换原则抽象，多态（行为多态、对象多态）。 4、依赖倒置原则高层和低层都应该依赖抽象，抽象接口之间进行依赖。 5、接口隔离原则客户端不应该依赖所不需要的接口。 6、迪米特原则减少类之间的依赖，降低耦合。 单例模式创建型模式，确保某一个类只有一个实例，并可以自行实例化并像整个系统提供这个实例 场景 某个对象过多消耗资源 某种类型的对象应该只有一个 实现 构造函数私有化 通过静态函数或者枚举返回单例对象 在多线程环境下，确保单例对象只有一个 在反序列化时，确保不会重新创建对象 种类 饿汉式（实例化类时就直接创建，消耗资源） 懒汉式（每次获取单例时，都会synchronized同步，消耗不必要的资源） 双重检查式（DCL，由于java自身问题，不适用于高并发情况） 静态内部类式（推荐使用，实例化内部类时才会创建实例，线程安全、对象单一） 枚举单例（线程安全、对象单一，无反序列化问题） 容器式（使用map容器保存单例，如获取Android系统服务） 优点 减少内存开支，尤其是需要频繁创建销毁一个对象，性能又无法优化时 所创建的对象占资源比较大，可以只创建一个对象，永驻内存 避免同一资源的同时操作 优化全局资源的共享 缺点 没有接口，扩建较为困难 如果单例对象持有Context对象，容易发生内存泄漏，如果使用，最好使用ApplicationContext 建造者模式创建型模式，将一个复杂的对象的构建与表示分离，使得同样的构建过程可以表示为不同的形式，允许用户不知道内部的构造细节，但可以更加精确的控制对象的构造流程 场景 多个部件或者零件都可以装配到一个对象中，但产生的结果不同时 初始化一个对象或者产品类特别复杂，如参数多，但有默认值时 实现 Product产品类——产品的抽象类 Builder——抽象的Builder，规范组建，常使用调用链实现（返回值为本对象，代码简介、易懂） ConcreteBuilder——具体的Builder类 Director——统一组装过程 优点 良好的封装性，构建时不比知晓内部构建细节 良好的扩展性，建造者独立 缺点 产生多余的Builder和Dirctor对象，消耗内存 原型模式创建型模式，复制原型实例，创建一个相同的对象，不会执行构造函数 场景 创建一个对象需要特别多的数据准备、访问权限，类初始化时消耗很多资源 保护性拷贝，避免自己的对象被修改 实现实现 继承Cloneable接口 重写方法clone() 修改clone()方法访问权限为protect或者public return super.clone()等操作 浅拷贝（影子拷贝）内部引用类型数据还是使用的相同地址，数据对象为同一个 深拷贝（推荐使用）内部引用类型的数据也被clone，与原型数据不是同一个 优点在内存中进行二进制流拷贝，性能好，速度快 缺点构造函数不会执行，开发时应该注意 工厂模式创建型模式，定义一个用于创建对象的接口，让子类决定实例化哪个类 场景 生成复杂对象 实现实现 抽象工厂——Factory 具体工厂——ConcreteFactory 抽象产品——Product 具体产品——ConcreteProduct 多工厂模式经常使用反射更简洁的生产某个对象 静态工厂模式直接返回某个产品实例，工厂类比较多 优点 扩展性好 耦合低 缺点 新增加产品时，要引入抽象层，导致类结构复杂化 策略模式行为型模式，封装一系列的算法，它们可以相互替换，分离算法，让算法独立于它的客户端而独立变化 场景 针对同种问题可用多种算法处理时 需要安全的封装多种同类型操作时 同一抽象有多个子类，需要用if-else/switch-case来具体选择子类时 实现Android中的时间插值器TimeInterpolator Context——用来操作策略的上下文环境，维护Strategy抽象的实例 Strategy——策略的抽象 ConcreteStrategyA、ConcreteStrategyB——具体的策略实现 优点 结构清晰明了，简单直观 耦合度相对较低，易扩展 封装彻底，数据安全 缺点 随着策略的增加，类的数量也会增加 状态模式行为型模式，当一个对象内在的状态改变时，允许改变它的行为 注意 结构类似于策略模式，但是目的、本质不同。 状态模式的行为是平行的、不可替换的 策略模式的行为是彼此独立、可相互替换的 根据自身的情况将不同状态作为不同的独立对象，不同的状态对象之间不依赖其他对象，可独立变化 场景 一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为，如Android中的Wi-Fi状态 代码中包含大量的状态判断语句，如if-else、switch-case。 实现 Context——环境类，维护一个State子类的实例，这个实例定义了对象的当前状态 State——抽象状态类或者状态接口，定义一个或一组接口，表示该状态下的行为 ConcreteStateA、ConcreteStateB——具体的状态类，实现State接口，不同状态有不同的行为 优点 结构清晰，扩展性和维护性高，符合单一职责原则 缺点 增加类和对象的个数 责任链模式行为型模式，使多个对象都有机会处理同一个请求，将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理为止 场景 多个对象可以处理同一个请求，但具体由谁处理动态决定 实现 Handler——抽象处理角色，声明处理方法，并保持对下一个处理者的引用 ConcreteHandlerA、ConcreteHandlerB——具体处理角色，处理请求或者转发给下一个处理者 Request——抽象请求，声明被处理时的方法 ConcreteRequestA、ConcreteRequestB——具体请求，实现被处理时的方法 注意 纯的责任链：被某个对象处理 不纯的责任联：没有被对象处理（常用） 两个行为，一是处理请求，二是传递给下一个对象，不允许处理后传递给上一个对象 优点 将请求者和处理者解耦，提高代码灵活性 缺点 如果处理者过多，会影响性能，尤其是递归调用 观察者模式行为型模式，一对多的依赖关系，当被观察者改变时，所有依赖它的观察者对象都会得到通知并会自动更新 场景 事件多级触发场景 消息交换场景，如消息队列，事件总线等 Android中数据库观察更新 实现 Subject（Observable）——抽象主题，把所有观察者对象的引用保存在一个集合中，并提供接口，可以增删观察者对象 ContreteSubject（ContreteObservable）——具体主题，当状态改变时，通知观察者 Observer——抽象观察者，定义一个接口，当主题改变时通知时改变自己 ConreteObserver——具体观察者，实现抽象观察者的接口 优点 将观察者和被观察者抽象耦合，应对业务变化 增强系统的灵活性和扩展性 缺点 观察者如果过多，会影响性能 如果一个观察者中途卡顿，必定影响整体效率，这时候要考虑使用异步处理 代理模式（委托模式）结构型模式，提供一种代理以控制对这个对象的访问 场景 无法或者不想直接访问这个对象时 访问某个对象比较困难时 注意 为了保证客户端使用的透明性，委托对象需要与被代理对象实现相同的接口 实现静态代理 Subject——抽象主题类或者接口，声明真实主题与代理接口的共同方法 RealSubject——真实主题类，被委托类或者被代理类，操作实际的业务逻辑 ProxySubject——代理类，持有真实主题类的引用，实现的接口方法操作真实主题类实现的接口方法 动态代理(一脸懵逼中…)java提供了动态代理接口InvocationHandler public class DynamicProxy implements InvocationHandler{ private Object mRealSubject; public DynamicProxy(Object mRealSubject){ this.mRealSubject = mRealSubject; } @Override public Object invoke(Object proxy, Method method, Object[] args){ return method.invoke(mRealSubject, args); } } public static void main(String[] args){ Subject realSubject = new RealSubject(); DynamicProxy proxy = new DynamicProxy(realSubject); Subject subject = (Subject)Proxy.newProxyInstance(realSubject.getClass.getClassLoader(), new Class[]{ Subject.class }, proxy); subject.innerMethod(); } 适配器模式结构型模式，将两个不同接口的对象粘合起来协同工作 场景 接口不兼容或者彼此之间没有联系的类 需要统一的输出接口，但输入类型未知 实现类适配器模式容易暴露一些奇怪的接口，用户使用成本变高 Target——目标角色，也就是所期待的接口 Adaptee——现有类，自己的接口，需要去转换 Adapter——适配器角色，继承自Adaptee，实现Target接口，将Adaptee现有接口转换为期待接口 对象适配器模式灵活，更加实用 Target——目标角色，也就是所期待的接口 Adaptee——现有类，自己的接口，需要去转换 Adapter——适配器角色，拥有Adaptee实例，实现Target接口，将Adaptee现有接口转换为期待接口 优点 更好的复用性 更好的扩展性 缺点 过多的使用适配器，会让系统显得凌乱，不易整体把握 装饰模式（包装模式）结构型模式，动态的给一个对象增加额外的功能，相比与继承更加灵活，是继承关系的一种替代方案，如onCreate()方法 实现 Component——抽象组件，一个接口或者抽象类，充当被装饰的原始对象 ConcreteComponent——组件具体实现类，实现Component接口，也就是被实际装饰的对象 Decorator——抽象装饰者，继承自Component，保持一个Component的引用 ConcreteDecoratorA、ConcreteDecoratorB——装饰者的具体实现类，对抽象装饰者做出具体的实现 注意装饰模式和代理模式相似，容易混淆 装饰模式是扩展对象功能，是对继承的一种替代方案 代理模式是对拥有的对象进行控制，不会增强功能 MVC介绍 MVC是一种框架模式，不是设计模式，但可以看作观察者模式、策略模式、组合模式的合体，核心在观察者模式。 框架面向于相同行为代码的重用 设计面向于相同结构代码的重用 架构介于框架和设计模式之间 框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度 三种级别的重用 内部重用：在同一应用中能公共使用的抽象块 代码重用：将通用模块组合成库或者工具集，以便在多个应用和领域都能使用 框架重用：为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性 Android中的MVC View——XML文件 Controller——Activity Model——数据处理 作用 控制器Activity主要作用就是解耦，将视图View和模式Model进行分离，两者在Activity中进行绑定或者完成其他的逻辑 MVP介绍 MVP模式可以分离显示层和逻辑层，它们之间通过接口通信，依赖接口，降低耦合 Android中的MVP Presenter——交互中间人 Presenter主要作为沟通View和Model的桥梁，他从Model层检索数据之后，返回给View层，使View和Model之间没有耦合，也将业务逻辑从View上抽离出来。 View——用户界面 View通常指Activity、Fragment或者某个View控件，它含有一个Presenter成员变量。通常View需要实现一个IView逻辑接口，将View上的操作通过会转交给Presenter进行实现，最后Presenter调用IView逻辑接口将结果返回给View元素。 Model——业务模型 Model角色的主要功能是提供数据的存取。Model是封装了数据库DAO或者网络获取数据的角色。 与MVC区别MVC特点 用户可以向View发送指令，再由View直接调用Model改变状态 用户也可以向Controller发送指令，再由Conroller调用View或者Model改变状态 Controller起到事件路由的作用，同时部分业务逻辑也部署在Controller中 区别 MVC的耦合性还是相对较高的，View可以直接与Model交互，导致M、V、C直接构成回路 MVP中的View和Model不能直接通信，需要经过Presenter间接发出请求通信 MVP的生命周期问题 内存泄漏 假设请求网络数据，Presenter拥有Activity的强引用，如果在请求结束之前Activity被销毁了，网络请求还没有返回，导致Presenter一直持有Activity对象，使得Activity对象无法被回收，此时发生了内存泄漏 解决方案 在Activity的生命周期中添加Presenter创建、销毁的方法 建立一个BaseActivity和BasePresenter，在BaseActivity的生命周期中添加BasePresenter的生命周期方法 Presenter中最好对View的引用为软引用，如果Activity没有走生命周期方法直接销毁了，也不会造成内存泄漏，但可能出问题。 优点 良好的扩展性、可测试性、稳定性、可维护性、整洁性、灵活性 职责单一、抽象、最小化、低耦合","categories":[{"name":"技术类","slug":"技术类","permalink":"http://jeson.org/categories/技术类/"}],"tags":[{"name":"android","slug":"android","permalink":"http://jeson.org/tags/android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://jeson.org/tags/设计模式/"}]},{"title":"Linux基本使用","slug":"笔记-Linux使用","date":"2016-08-31T16:00:00.000Z","updated":"2017-05-13T11:00:04.014Z","comments":true,"path":"2016/09/01/笔记-Linux使用/","link":"","permalink":"http://jeson.org/2016/09/01/笔记-Linux使用/","excerpt":"","text":"基本命令ls 查询目录中的内容ls [选项] [文件或者目录] -a 所有文件，包括隐藏文件 -l 详细信息 -h 人性化显示，byte --&gt; KB -d 查看目录属性 -i 显示inode值 ll=ls -l mkdir 创建目录mkdir [选项] 目录 -p 创建多级目录，递归创建 cd 切换目录cd [目录] ~/空值 进入当前用户目录 - 进入上次进入的目录 .. 进入上级目录 . 进入当前目录 tab键 自动补全（点击一下）或者提示所有类似文件（点击两下） rmdir 删除一个空白目录，目录不能有任何内容rmdir 空白目录 rm 删除目录或者文件rm [选项] 目录或者文件名 -r 删除目录 -f 强制删除，不会提醒删除 rm -rf / 谨慎使用，删除根目录所有文件 cp 复制cp [选项] 源文件或者源目录 目标文件或者目标目录 -r 复制目录 -p 连带文件属性一同复制 -d 若源文件位链接文件，则复制链接属性 -a 复制所有属性，相当于-pdr mv 剪切或者改名，同一目录下剪切就是改名字，不同目录下就是剪切mv 源文件或者目录 目标文件或者目录 ln 生成链接文件ln [选项] 源文件 目标文件 -s 创建软链接 / 一级目录作用/bin 通用命令 /sbin 超级用户命令 /boot 启动 /dev 硬件文件 /etc 配置文件 /home 普通用户家目录 /root 超级用户家目录 /lib 函数库 /mnt 硬盘，光盘等存储设备挂载点 /media 光盘挂载点 /misc 磁带之类挂载点 /proc 内存挂在点 /sys 内存挂载点 /tmp 临时文件目录 /usr 系统软件资源目录 /usr/bin 用户系统命令（通用） /usr/sbin 用户系统命令（超级） /var 系统的可变文档目录 locate 在后台数据库中按文件名搜索，搜索速度快，只能按照文件名搜索locate 文件名 /etc/updatedb.conf 配置文件 updatedb 更新数据库（默认一天一搜索） /var/lib/mlocate/mlocate.db whereis 搜索命令所在的路径及帮助文档所在位置，找到的命令不是shell自带的whereis 命令名 -b 只查找可执行文件 -m 只查找帮助文件 which 同whereis 但会增显别名（若存在），不显示帮助文档，无参数，不常用 echo $PATH 环境变量 find 搜索文件find [搜索范围] [搜索条件，可以有多个] 搜索文件名 文件名作为过滤条件 -name 以文件名进行搜索 -iname 以文件名（不区分大小写）进行搜索 用户所有者作为过滤条件 -user 按所有者搜索 例：find /root -user root -nouser 查找没有所有者的文件 时间作为过滤条件 -mtime 内容改变的时间 -ctime 属性改变的时间 -atime 最近访问的时间 例：find ./ -mtime +10(-10或者10) 查找10天前（10天内或者第10天前）的文件 大小作为过滤条件 -size 文件占用空间大小，大小的单位默认位数据块，扇区，可选的大小为：b（小写，B）k（小写，KB），M（大写，MB），G（大写，GB） 例：find ./ -size 25k 节点信息作为过滤条件 -inum inode的节点信息 例：find ./ inum 26421 通配符 * 匹配任意字符 ? 匹配任意一个字符 [abc] [a-z] [0-9]匹配[]内的任意一个字符 [^a-z] 匹配的内容不包含[]的任意一个字符 条件逻辑 -a 代表and，并且 -o 代表or，或者 find ./ -size +20k -a -mtime -10 结果处理 -exec 需要执行的命令 {} \\; find ./ -size +20k -a -mtime -10 -exec ls -l {} \\; grep 搜索字符串grep [选项] 字符串 文件名 -i 忽略大小写 -v 排除指定字符串 man 帮助命令man [等级] 命令 man [选项] 命令 -f 相当于 whatis 命令 = man -f 命令 -k 所有含有关键字的命令或者文件 help 查询help 命令 info 详细的帮助命令info 命令 zip 压缩为zip格式，与windows通用zip [选项] 文件名 源文件 -r 压缩目录 unzip 解压缩zip格式unzip 文件名 gzip 压缩为gzip格式或解压缩gzip格式文件gzip [选项] 源文件 [目标目录] -c 保留源文件，需要加重定向符号 例：gzip -c test &gt; t1 -r 压缩目录下所有子文件，但不包括目录 -d 解压缩gzip文件，等同于gunzip ？？？好像有问题 bzip 压缩为bzip2格式，不能压缩目录bzip [选项] 源文件 -k 源文件，保留源文件 -d 解压缩，同bunzip2 tar 打包命令tar [选项] 打包文件名 源文件 -c 打包，与-x/-t -v 显示过程 -f 指定打包的文件名 例：tar -cvf long.tar long -x 解压缩包，与-c/-t对应 -z 打包时并压缩为gz格式 -j 打包时并压缩为bz2格式 -C 大写C，指定解压缩目录 -t 查看压缩文件内容，与-x/-c对应 shutdown 关机重启命令shutdown [选项] 时间 -c 取消前一个关机命令 -h 关机 -r 重启 关机halt poweroff init 0 关机，不建议使用 重启reboot/init 0 init 系统运行级别init [level] 0 关机 1 单用户，类似于安全模式 2 不完全多用户，不含NFS服务 3 完全多用户，默认 4 未分配 5 图形界面 6 重启 logout 退出登录df 查询系统中已经挂载的设备mount 查询系统中已经挂载的设备mount [-t 文件系统] [-o 特殊选项] 设备名 挂载点 -a 依据配置文件/etc/fstab的内容自动挂载 -t 文件系统，（光盘，iso9660） -o 特殊选项 exec/noexec：可执行，默认为exec rw/ro：读写权限，默认为rw 例：mount -t iso9660 -o ro /etc/sr0(或/etc/cdrom) /mnt/cdrom mount /dev/sr0 /mnt/cdrom 例：mount -t vfat /dev/sdb1 /mnt/usb 挂载fat32位格式硬盘 umount 卸载，卸载时挂载点不在使用状态，也不可在当前目录umount 设备文件名或挂载点 例：umount /mnt/cdrom fdisk 查看硬盘设备fdisk [选项] -l 列出硬盘 w 查看用户登录信息w [用户名] who 查看用户登录信息who [用户名] last 查询当前目录和过去登录的用户信息默认是读取/var/log/wtmp文件的数据 lastlog 查看用户最后一次登录时间shell 命令行解释器，配置在/etc/shells，可以通过exit退出sh或csh 进入相应shell命令 echo 输出命令，输出的内容如果含有空格，则需要用双引号包裹echo [选项] [输出内容] -e 支持反斜线空值的字符转换 控制字符 作用 \\a 输出警告音 \\b 退格键，也就是一个向左删除键 \\n 换行符 \\r 回车符 \\v 垂直制表符 \\onnn 八进制输出字符 \\xhh 十六进制输出字符 \\t 制表符tab 输出颜色 #30m = 黑，31m = 红，32m = 绿，33m = 黄，34m = 蓝，35m = 洋红，36m = 青，37m = 白 例：echo -e &quot;\\e[1;31mhelloworld\\e[0m&quot; \\e 调用颜色 [1; 开启颜色，\\e[1;31m [0m 关闭颜色, \\e[0m 脚本执行#代表注释 #！/bin/bash 代表以下内容为shell脚本，如果不是纯shell语言则必须加 执行方法： 1. 赋予执行权限，直接运行 chmod 755 hello.sh ./hello.sh 2. 通过Bash调用执行脚本 bash shell.sh alias 给命令添加别名（关机后消失）alias 别名=&apos;命令&apos; 例：alias ls=&apos;ls --color=never&apos; 在~/.bashrc 添加别名，可永久生效，可通过source .bashrc 命令生效顺序: 1. 用绝对路径或相对路径执行命令 2. 别名 3. Bash的内部命令 4. 按照$PATH环境变量找到的第一个命令 unalias 删除别名（临时删除）快捷键ctrl + c 终止当前命令 ctrl + l 清屏 ctrl + a 光标移至行首 ctrl + e 光标移至行尾 ctrl + u 从光标位置删除至行首 ctrl + z 将命令放置后台 ctrl + r 在历史命令中搜索 history 历史命令history [选项] [历史命令保存文件] -c 清空历史命令 -w 缓存中的历史命令保存文件 ~/.bash_history wc 统计信息wc [选项] [文件名] -c 统计字符数 -w 统计单词数 -l 统计行数 例： wc -wcl test.txt 输出内容： 行数 单词数 字节数 路径 标准输入输出键盘 /dev/stdin 0 显示器 /dev/stdout 1 显示器 /dev/stderr 2 输出重定向&gt; 覆盖 &gt;&gt; 追加 &gt; 只存储命令正确执行时内容 例： ls &gt; test.txt ls列表内容存入到test.txt文件中，只存命令正确执行时的内容 2&gt; 只存储命令错误执行内容 例： lss 2&gt; test.txt ls列表内容存入到test.txt文件中，只存命令错误执行时的内容 &amp;&gt; 或 2&gt;&amp;1 命令正确或者错误执行后输出内容都保存 例： ls &gt; test.txt 2&gt;&amp;1 ls &amp;&gt; test.txt &gt; 文件一 2&gt; 文件二 命令正确和错误执行后内容分开执行 例： ls &gt; test.txt 2&gt; test_error.txt /dev/null 黑洞例： ls &gt; test.txt 2&gt; /dev/null 输入重定向, 不懂&lt; &lt;&lt; 多命令顺序执行 多命令执行符 格式 作用 ; cmd1;cmd2 多个命令顺序执行，命令之间无任何逻辑关系，无论哪个cmd出错都会顺序执行下一个 &amp;&amp; cmd1&amp;&amp;cmd2 逻辑与，cmd1正确执行后才会执行cmd2 丨 cmd1丨丨cmd2 逻辑或，cmd1正确执行后不会执行cmd2，cmd1错误执行后cmd2才会执行 例： ls &amp;&amp; echo success || echo fail 正确 --&gt; success X--&gt; 错误 X--&gt; --&gt; fail ls || echo fail &amp;&amp; echo success 逻辑混乱，不建议 | 管道符，管道符前面的命令输出作为后面命令的操作对象cmd1 | cmd2 cmd1的处理结果送于cmd2作为处理对象 Bash中其他特殊符号 符号 名称 作用 ‘’ 单引号 在单引号中所有的特殊字符都无特殊含义 “” 双引号 取消特殊含义，$和\\ $() 变量的值，引用命令，转义符等特殊含义 ·· 反引号 同$()， 建议使用$() # 井号 在shell脚本中代表注释 $ 用于调用变量的值，例：$name \\ 转义符 转义其后的字符，相当于用单引号括起来","categories":[{"name":"技术类","slug":"技术类","permalink":"http://jeson.org/categories/技术类/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jeson.org/tags/Linux/"},{"name":"Linux基本使用","slug":"Linux基本使用","permalink":"http://jeson.org/tags/Linux基本使用/"}]},{"title":"IT技术网站","slug":"IT技术网站","date":"2016-07-31T16:00:00.000Z","updated":"2017-05-13T10:59:53.879Z","comments":true,"path":"2016/08/01/IT技术网站/","link":"","permalink":"http://jeson.org/2016/08/01/IT技术网站/","excerpt":"","text":"慕课网：免费视频教学 CSDN：最大的中文IT社区 开源中国社区：很多源码 51CTO：技术论坛 安卓社区 Linux在线学习网站： 测试相关网站 CTS框架解析 Gradle自学合集 Android常用adb命令总结 Android测试常用脚本 图标库 手机app设计 JS/CSS开源库 环信即时通信 免费服务器 json转换为实体类 RecyclerView介绍使用 安卓源码网站1 安卓源码网站2 Android利用canvas画各种图形 android控件效果 查看安卓源码 android studio 安装以及简单使用教程/技巧1 android studio 安装以及简单使用教程/技巧2 安卓镜像网站 映纷创意 隐式调用 Intent 大全","categories":[{"name":"参考类","slug":"参考类","permalink":"http://jeson.org/categories/参考类/"}],"tags":[{"name":"android","slug":"android","permalink":"http://jeson.org/tags/android/"},{"name":"技术","slug":"技术","permalink":"http://jeson.org/tags/技术/"},{"name":"网站","slug":"网站","permalink":"http://jeson.org/tags/网站/"}]}]}